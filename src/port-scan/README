This is simple port scanner using go

############
VERSION-1
############

This port scanner scans port on scanme.nmap.org. Prints if port connection was successful or not.

############
VERSION-2
############

This port scanner scans ports on scanme.nmap.org. Prints if port connection was successful or not.
It checks for all the ports from 1 to 1024 with simple for loop. It checks one by one and is
very slow. 

############
VERSION-3
############

This port scanner scans ports on scanme.nmap.org. Prints if port connection was successful or not.
This version launches single go routine per connection, and the main go routine doesn't know to wait
for main connection to take place. Therefore, the code completes and exists as soon as the for loop 
finishes the iterations, which may be faster than the network exchange of packets between the code and 
target ports. We may not get accurate results for ports whose packets were still in-flight.
Let's try fixing this in new version.

############
VERSION-3
############

This port scanner scans ports on scanme.nmap.org. Prints if port connection was successful or not.
Using WaitGroup from the sync package, which is a thread-safe way to control concurrency. 
WaitGroup is a struct type and can be created like `var wg sync.WaitGroup`

Once you’ve created WaitGroup, you can call a few methods on the struct. The first is Add(int), 
which increases an internal counter by the number provided. Next, Done() decrements the
counter by one. Finally, Wait() blocks the execution of the goroutine in which it’s called, 
and will not allow further execution until the internal counter reaches zero. You can
combine these calls to ensure that the main goroutine waits for all connections to finish.

